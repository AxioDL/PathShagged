#include <iostream>
#include <string.h>
#include <tinyxml2.h>

#include <unordered_map>
#include <map>
#include <functional>
#include <memory>
#include <Athena/IStreamReader.hpp>
#include <Athena/IStreamWriter.hpp>
#include <Athena/DNA.hpp>
#include <Athena/DNAYaml.hpp>
#include "../DataSpec/DNACommon/IProperty.hpp"

typedef char* FourCC;

#define EXPECTED_PROPERTY_VERSION 4

enum class ParseError : atInt32
{
    Success            = 0,
    InvalidArgs        = -1,
    InvalidGame        = -2,
    UnsupportedVersion = -3,
    InputFileNotFound  = -4,
    OutputFileNotFound = -5
};

std::unordered_map<std::string, std::string> typeTranslation = {
    { "long",       "Retro::DNACommon::IntProperty"     },
    { "float",      "Retro::DNACommon::FloatProperty"   },
    { "vector3f",   "Retro::DNACommon::Vector3Property" },
    { "color",      "Retro::DNACommon::ColorProperty"   },
    { "bool",       "Retro::DNACommon::BoolProperty"    },
    { "array",      "Retro::DNACommon::ArrayProperty"   },
    { "string",     "Retro::DNACommon::StringProperty"  },
    { "animparams", "Retro::DNAMP1::AnimationParameters"},
};

std::map<std::string, std::string> typeTranslationCase = {
    { "unknown",    "UnknownProperty" },
    { "long",       "IntProperty"     },
    { "float",      "FloatProperty"   },
    { "vector3f",   "Vector3Property" },
    { "color",      "ColorProperty"   },
    { "bool",       "BoolProperty"    },
    { "array",      "ArrayProperty"   },
    { "string",     "StringProperty"  },
    { "animparams", "AnimationParametersMP2"},
};

std::map<std::string, std::vector<atUint32>> typeIdMap;

int main(int argc, char *argv[])
{
    Retro::DNACommon::UniqueID32Property var("BLARG", Retro::UniqueID32(1234), "Booty");
    std::cout << var.DNAType() << std::endl;
    if (argc < 5)
    {
        fprintf(stderr, "Usage: propparse <game-dir> <out-dir> <mp2|mp3>\n");
        return int(ParseError::InvalidArgs);
    }

    const char* in = argv[1];
    const char* out = argv[2];
    const char* projectPath = argv[3];
    // TODO: Use these
    bool isMP2 = !strcasecmp(argv[4], "mp2");
    bool isMP3 = !strcasecmp(argv[4], "mp3");
    if (!isMP2 && !isMP3)
    {
        fprintf(stderr, "Invalid game specified, only mp2 and mp3 are supported\n");
        return int(ParseError::InvalidGame);
    }


    tinyxml2::XMLDocument doc;
    if (doc.LoadFile(in) == tinyxml2::XML_SUCCESS)
    {
        tinyxml2::XMLElement* root = doc.FirstChildElement("Properties");
        atUint32 version = strtol(root->Attribute("version"), nullptr, 0);
        if (version != EXPECTED_PROPERTY_VERSION)
        {
            fprintf(stderr, "Unsupported property version %i expected %i\n", version, EXPECTED_PROPERTY_VERSION);
            return int(ParseError::UnsupportedVersion);
        }

        FILE* src = fopen(out, "w");

        if (!src)
        {
            fprintf(stderr, "Unable to open or create target file \"%s\"\n", out);
            return int(ParseError::OutputFileNotFound);
        }

        fprintf(src, "/***************************************************************************\n"
                     " *                   Automatically generated by propparse                  *\n"
                     " *                              DO NOT MODIFY                              *\n"
                     " * propparse is part of PathShagged and is available under the MIT license *\n"
                     " * for more information go to: https://github.com/AxioDL/PathShagged       *\n"
                     " ***************************************************************************/\n"
                     "\n"
                     "#include \"%s/IProperty.hpp\"\n"
                     "namespace Retro\n"
                     "{\n"
                     "namespace DNAMP2\n"
                     "{\n"
                     "const std::map<atUint32, IPropertyFactoryBase*> PropertyDatabase =\n{\n",
                projectPath);

        if (root)
        {
            tinyxml2::XMLElement* child = root->FirstChildElement();
            while (child)
            {
                const char* elementType = child->Value();
                bool isProperty = !strcmp(elementType, "property");
                bool isStruct = (!isProperty && !strcmp(elementType, "struct"));
                atUint32 id = strtol(child->Attribute("ID"), nullptr, 0);
                std::string name(child->Attribute("name"));
                if (isProperty)
                {
                    std::string type(child->Attribute("type"));
                    if (typeTranslation.find(type) != typeTranslation.end())
                    {
                        typeIdMap[typeTranslationCase[type]].push_back(id);
                        fprintf(src, "    { 0x%.8X, new Retro::DNAMP2::IPropertyFactory<%s>(\"%s\", 0x%.8X)},\n", id, typeTranslation[type].c_str(), name.c_str(), id);
                    }
                    else if (!type.compare("file"))
                    {
                        if (isMP2)
                            typeIdMap["FileProperty"].push_back(id);
                        else if (isMP3)
                            typeIdMap["File64Property"].push_back(id);

                        std::string ext(child->Attribute("ext"));
                        fprintf(src, "    { 0x%.8X, new Retro::DNAMP2::ResourcePropertyFactory(\"%s\", FOURCC('%s'), 0x%.8X)},\n", id, name.c_str(), ext.c_str(), id);
                    }
                    else
                        fprintf(src, "    { 0x%.8X, new Retro::DNAMP2::IPropertyFactory<%s>(\"%s\", 0x%.8X)},\n", id, type.c_str(), name.c_str(), id);

                }
                else if (isStruct)
                {
                    fprintf(src, "    { 0x%.8X, new Retro::DNAMP2::IPropertyFactory<Retro::DNAMP2::StructProperty>(\"%s\", 0x%.8X)},\n", id, name.c_str(), id);
                    if (id == 'XFRM')
                        typeIdMap["Transform"].push_back(id);
                    else if (id == 0x8249F6C7)
                        typeIdMap["LayerParametersMP2"].push_back(id);
                    else
                        typeIdMap["StructProperty"].push_back(id);
                }
                child = child->NextSiblingElement();
            }
        }

        fprintf(src, "}; // PropertyDatabase \n"
                     "}\n"
                     "}\n");
        fclose(src);
    }
    else
    {
        fprintf(stderr, "Unable to open \"%s\\n", in);
        return int(ParseError::InputFileNotFound);
    }

    return int(ParseError::Success);
}
